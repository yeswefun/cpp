



静态成员属于类，所有类的实例共享同一份数据
    所以不能在构造中赋值，因为每次都会重置

静态属性
    类内声明，类外初始化



非静态函数可以访问所有成员
静态函数只能访问静态成员



单例设计模式
    私有化默认构造
    私有化拷贝构造
    私有化静态成员属性
        类内声明，类外初始化
    公开方法
    注：单例一般不需要手动释放单例对象，程序运行完后系统会自动释放




成员属性与成员函数分开存储
非静态成员变量，属于对象


this - 指向当前对象的指针
    因为类的方法是所有对象共享的，所以必须有东西能区分到底是谁正在调用当前方法



this可以解决命名冲突
链式调用



this指针指向NULL
    不操作对象成员属性是没有问题的



const Dog * const this; // 只读指针
this = NULL; // error，指向不能改变-指针常量
*this = NULL;// error，指向的变量也不能改变-常量指针


常函数
    不允许修改this指针指向的对象的成员
    
    void test() const {
        // ...
    }

    mutable 无视常函数，在常函数中也可以修改


常对象
    
    const Dog dog2;

    1.常对象属性的值不允许修改

    2.常对象只可以调用常函数



友元函数 - 访问类中的私有成员

    全局函数作友元函数
    另一个类作为友元成员
    另一个类的成员函数作为友元成员


    全局函数作友元函数
        class Safe {
            // 友元函数 - 访问类中的私有成员
            friend void testFriend(Safe *s);
        }


    另一个类作为友元成员
        class Safe {
            /*
                单方向: User -> Safe
                不传递: A -> B; B -> C; but A x-> C
                友元函数 - 访问类中的私有成员
            */
            friend class User;
        }

        拆成声明与实现的形式，参考 12_friend.cpp


    另一个类的成员函数作为友元成员
        class Safe {
            friend void User::test();
        }






